# 연관규칙 마이닝 완벽 가이드
## Apriori & FP-Growth 알고리즘

## 목차
1. [연관규칙 마이닝 기초](#1-연관규칙-마이닝-기초)
2. [Apriori 알고리즘](#2-apriori-알고리즘)
3. [FP-Growth 알고리즘](#3-fp-growth-알고리즘)
4. [알고리즘 비교](#4-알고리즘-비교)
5. [실전 문제](#5-실전-문제)
6. [Python 구현](#6-python-구현)

---

## 1. 연관규칙 마이닝 기초

### 1.1 기본 개념

**연관규칙 마이닝(Association Rule Mining)**
- 대규모 데이터에서 항목 간의 연관성을 발견하는 기법
- 장바구니 분석(Market Basket Analysis)이 대표적 응용 분야

**주요 용어**

| 용어 | 설명 | 예시 |
|------|------|------|
| **항목(Item)** | 개별 상품 | 우유, 빵, 버터 |
| **항목집합(Itemset)** | 항목의 집합 | {우유, 빵} |
| **거래(Transaction)** | 한 번의 구매 내역 | T1: {우유, 빵, 버터} |
| **k-항목집합** | k개 항목으로 구성된 집합 | {우유, 빵}은 2-항목집합 |
| **빈발 항목집합** | 최소 지지도를 만족하는 항목집합 | 지지도 ≥ min_support |

### 1.2 부분집합(Subset) 개념

**부분집합의 중요성**

집합 {A, B, C}의 모든 부분집합:
```
∅ (공집합)
{A}, {B}, {C}
{A,B}, {A,C}, {B,C}
{A,B,C}
```

**k-항목집합의 부분집합 개수:** 2^k - 1 (공집합 제외)

**예제:** {우유, 빵, 버터}의 부분집합
- 1-항목집합: {우유}, {빵}, {버터}
- 2-항목집합: {우유, 빵}, {우유, 버터}, {빵, 버터}
- 3-항목집합: {우유, 빵, 버터}

**Apriori 원리에서 부분집합의 역할:**
> 빈발 항목집합의 모든 부분집합도 빈발 항목집합이다.

**반대로:**
> 비빈발 항목집합을 포함하는 모든 상위집합도 비빈발이다.

### 1.3 연관규칙의 측도

#### 지지도 (Support)

```
Support(X) = |X가 포함된 거래| / |전체 거래|
Support(X → Y) = P(X ∩ Y) = |X와 Y가 함께 포함된 거래| / |전체 거래|
```

#### 신뢰도 (Confidence)

```
Confidence(X → Y) = P(Y|X) = Support(X ∪ Y) / Support(X)
                   = |X와 Y가 함께 포함된 거래| / |X가 포함된 거래|
```

#### 향상도 (Lift)

```
Lift(X → Y) = Confidence(X → Y) / Support(Y)
            = P(Y|X) / P(Y)
            = Support(X ∪ Y) / (Support(X) × Support(Y))
```

**해석:**
- Lift = 1: X와 Y는 독립 (연관성 없음)
- Lift > 1: X를 구매하면 Y를 구매할 가능성 증가 (양의 연관성)
- Lift < 1: X를 구매하면 Y를 구매할 가능성 감소 (음의 연관성)

---

## 2. Apriori 알고리즘

### 2.1 Apriori 원리

**핵심 원리:**
```
빈발 항목집합의 모든 비어있지 않은 부분집합도 빈발 항목집합이다.
```

**논리적 결과 (대우):**
```
어떤 항목집합이 비빈발이면, 
그 항목집합을 포함하는 모든 상위집합도 비빈발이다.
```

**가지치기(Pruning)에 활용:**
- 비빈발 항목집합 발견 시, 그것을 포함하는 모든 상위집합 탐색 중단
- 계산 횟수를 대폭 감소

### 2.2 Apriori 알고리즘 단계

**Step 1:** 최소 지지도(min_support) 설정

**Step 2:** 1-항목 빈발집합(L₁) 찾기
- 각 항목의 지지도 계산
- min_support 이상인 항목만 선택

**Step 3:** k-항목 빈발집합(Lₖ) 생성
- Lₖ₋₁에서 후보 Cₖ 생성
- Cₖ의 지지도 계산
- min_support 이상인 집합만 Lₖ에 포함

**Step 4:** 더 이상 빈발집합이 생성되지 않을 때까지 반복

**Step 5:** 빈발집합으로부터 연관규칙 생성

### 2.3 Apriori 계산 예제

**데이터:** 거래 데이터베이스

| TID | 구매 항목 |
|-----|----------|
| T1 | {A, B, C} |
| T2 | {A, C} |
| T3 | {A, B} |
| T4 | {B, C, D} |
| T5 | {A, B, C} |
| T6 | {B, C} |
| T7 | {A, B} |
| T8 | {A, B, C, D} |

**설정:** 최소 지지도(min_support) = 37.5% (3/8)

#### Step 1: 1-항목집합 C₁ 스캔

| 항목집합 | 거래 | 지지도 카운트 | 지지도(%) |
|----------|------|--------------|----------|
| {A} | T1,T2,T3,T5,T7,T8 | 6 | 75% |
| {B} | T1,T3,T4,T5,T6,T7,T8 | 7 | 87.5% |
| {C} | T1,T2,T4,T5,T6,T8 | 6 | 75% |
| {D} | T4,T8 | 2 | 25% ❌ |

**L₁ (빈발 1-항목집합):**
```
L₁ = {{A}, {B}, {C}}
```
- {D}는 지지도 25% < 37.5% → 제거

#### Step 2: 2-항목집합 C₂ 생성 및 스캔

**후보 생성:** L₁에서 조합
```
C₂ = {{A,B}, {A,C}, {B,C}}
```

**지지도 계산:**

| 항목집합 | 거래 | 지지도 카운트 | 지지도(%) | 결과 |
|----------|------|--------------|----------|------|
| {A,B} | T1,T3,T5,T7,T8 | 5 | 62.5% | ✓ |
| {A,C} | T1,T2,T5,T8 | 4 | 50% | ✓ |
| {B,C} | T1,T4,T5,T6,T8 | 5 | 62.5% | ✓ |

**L₂ (빈발 2-항목집합):**
```
L₂ = {{A,B}, {A,C}, {B,C}}
```

#### Step 3: 3-항목집합 C₃ 생성 및 스캔

**후보 생성:** L₂에서 조합
```
C₃ = {{A,B,C}}
```

**지지도 계산:**

| 항목집합 | 거래 | 지지도 카운트 | 지지도(%) | 결과 |
|----------|------|--------------|----------|------|
| {A,B,C} | T1,T5,T8 | 3 | 37.5% | ✓ |

**L₃ (빈발 3-항목집합):**
```
L₃ = {{A,B,C}}
```

#### Step 4: 4-항목집합 시도

```
L₃에서 더 이상 조합 불가 → 종료
```

#### 최종 빈발 항목집합

| k | 빈발 k-항목집합 |
|---|---------------|
| 1 | {A}, {B}, {C} |
| 2 | {A,B}, {A,C}, {B,C} |
| 3 | {A,B,C} |

### 2.4 연관규칙 생성

**최소 신뢰도(min_confidence) = 70%**

#### {A,B,C}로부터 규칙 생성

**가능한 규칙:**

| 규칙 | 지지도 | 신뢰도 계산 | 신뢰도 | 향상도 | 채택 |
|------|--------|------------|--------|--------|------|
| A → BC | 3/8=37.5% | 3/6 | 50% | - | ❌ |
| B → AC | 3/8=37.5% | 3/7 | 42.9% | - | ❌ |
| C → AB | 3/8=37.5% | 3/6 | 50% | - | ❌ |
| AB → C | 3/8=37.5% | 3/5 | 60% | - | ❌ |
| AC → B | 3/8=37.5% | 3/4 | 75% | 0.86 | ✓ |
| BC → A | 3/8=37.5% | 3/5 | 60% | - | ❌ |

**신뢰도 ≥ 70%인 규칙:**
```
AC → B: 신뢰도 75%
```

**해석:** A와 C를 함께 구매한 고객의 75%가 B도 구매했습니다.

### 2.5 Apriori 의사코드

```python
Algorithm: Apriori
Input: 거래 데이터베이스 D, 최소 지지도 min_sup
Output: 빈발 항목집합 L

1. L₁ = {빈발 1-항목집합 찾기}
2. k = 2
3. while Lₖ₋₁ ≠ ∅:
4.     Cₖ = apriori_gen(Lₖ₋₁)  // 후보 생성
5.     for each transaction t in D:
6.         Cₜ = subset(Cₖ, t)   // t에 포함된 후보
7.         for each candidate c in Cₜ:
8.             c.count++
9.     Lₖ = {c ∈ Cₖ | c.count ≥ min_sup}
10.    k = k + 1
11. return L = ∪ₖ Lₖ

Function: apriori_gen(Lₖ₋₁)
// Lₖ₋₁로부터 후보 Cₖ 생성
1. Cₖ = ∅
2. for each l₁ in Lₖ₋₁:
3.     for each l₂ in Lₖ₋₁:
4.         if l₁과 l₂의 처음 (k-2)개 항목이 같으면:
5.             c = l₁ ∪ l₂
6.             if c의 모든 (k-1)-부분집합이 Lₖ₋₁에 있으면:
7.                 Cₖ = Cₖ ∪ {c}
8. return Cₖ
```

### 2.6 Apriori 장단점

**장점:**
- 구현이 간단하고 이해하기 쉬움
- 완전한 결과 보장 (모든 빈발집합 찾음)
- 가지치기로 탐색 공간 축소

**단점:**
- 데이터베이스를 여러 번 스캔 (k번)
- 많은 후보 집합 생성
- 대규모 데이터나 긴 패턴에서 성능 저하

---

## 3. FP-Growth 알고리즘

### 3.1 FP-Growth 개요

**FP-Growth (Frequent Pattern Growth)**
- Apriori의 단점을 개선한 알고리즘
- 후보 생성 없이 빈발 패턴 탐색
- 데이터베이스를 2번만 스캔

**핵심 아이디어:**
1. 데이터를 **FP-Tree**(Frequent Pattern Tree) 구조로 압축
2. 트리를 이용해 빈발 패턴을 직접 추출

### 3.2 FP-Tree 구조

**FP-Tree 특징:**
- 압축된 데이터 구조
- 공통 경로 공유로 메모리 효율적
- 헤더 테이블로 항목별 노드 연결

**구성 요소:**

| 요소 | 설명 |
|------|------|
| **루트 노드** | null 값을 가진 시작점 |
| **항목 노드** | 항목:카운트 형태 |
| **헤더 테이블** | 항목별 지지도와 첫 노드 링크 |
| **노드 링크** | 같은 항목 노드들을 연결 |

### 3.3 FP-Growth 알고리즘 단계

**Phase 1: FP-Tree 구축**

**Step 1:** 1차 스캔 - 빈발 1-항목집합 찾기
- 각 항목의 지지도 계산
- 지지도 순으로 정렬

**Step 2:** 2차 스캔 - FP-Tree 생성
- 각 거래를 빈발항목만 추출하여 정렬
- 트리에 삽입 (공통 경로 공유)

**Phase 2: 빈발 패턴 마이닝**

**Step 3:** 각 항목에 대해 조건부 패턴 베이스 생성

**Step 4:** 조건부 FP-Tree 구축

**Step 5:** 재귀적으로 빈발 패턴 추출

### 3.4 FP-Growth 계산 예제

**데이터:** 동일한 거래 데이터

| TID | 구매 항목 |
|-----|----------|
| T1 | {A, B, C} |
| T2 | {A, C} |
| T3 | {A, B} |
| T4 | {B, C, D} |
| T5 | {A, B, C} |
| T6 | {B, C} |
| T7 | {A, B} |
| T8 | {A, B, C, D} |

**설정:** 최소 지지도 = 3 (37.5%)

#### Phase 1: FP-Tree 구축

**Step 1: 1차 스캔 - 빈발 항목 찾기**

| 항목 | 지지도 카운트 | 결과 |
|------|--------------|------|
| A | 6 | ✓ |
| B | 7 | ✓ |
| C | 6 | ✓ |
| D | 2 | ❌ (비빈발) |

**빈도순 정렬:** B(7) > A(6) = C(6)
**정렬 순서:** B > A > C

**헤더 테이블 (초기):**

| 항목 | 지지도 | 노드 링크 |
|------|--------|----------|
| B | 7 | null |
| A | 6 | null |
| C | 6 | null |

**Step 2: 2차 스캔 - FP-Tree 생성**

각 거래를 정렬 순서(B>A>C)로 변환:

| TID | 원래 항목 | 필터링 & 정렬 |
|-----|----------|--------------|
| T1 | {A,B,C} | {B,A,C} |
| T2 | {A,C} | {A,C} |
| T3 | {A,B} | {B,A} |
| T4 | {B,C,D} | {B,C} |
| T5 | {A,B,C} | {B,A,C} |
| T6 | {B,C} | {B,C} |
| T7 | {A,B} | {B,A} |
| T8 | {A,B,C,D} | {B,A,C} |

**트리 구축 과정:**

```
삽입 T1 {B,A,C}:
    null
     |
    B:1
     |
    A:1
     |
    C:1

삽입 T2 {A,C}:
    null
    / \
   B:1 A:1
   |    |
  A:1  C:1
   |
  C:1

삽입 T3 {B,A}:
    null
    / \
   B:2 A:1
   |    |
  A:2  C:1
   |
  C:1

삽입 T4 {B,C}:
    null
    / \
   B:3 A:1
   /\   |
  A:2 C:1 C:1
  |
 C:1

... (계속)
```

**최종 FP-Tree:**

```
          null
         /    \
       B:7    A:1
      /  \      \
    A:5  C:2    C:1
    |
   C:3
```

**최종 헤더 테이블:**

| 항목 | 지지도 | 노드 링크 체인 |
|------|--------|---------------|
| B | 7 | → B:7 |
| A | 6 | → A:5 → A:1 |
| C | 6 | → C:3 → C:2 → C:1 |

#### Phase 2: 빈발 패턴 마이닝

**Step 3: 조건부 패턴 베이스 (Conditional Pattern Base) 생성**

**C의 조건부 패턴 베이스:**

| 경로 | 카운트 |
|------|--------|
| B→A→C | 3 |
| B→C | 2 |
| A→C | 1 |

**조건부 패턴:** 
```
{B,A}:3
{B}:2
{A}:1
```

**C의 조건부 FP-Tree:**
```
항목 지지도:
B: 3+2 = 5 ✓
A: 3+1 = 4 ✓

정렬: B > A

트리:
   null
    |
   B:5
    |
   A:3
```

**C로부터 빈발 패턴:**
- {C}: 6 (원래 지지도)
- {B,C}: 5
- {A,C}: 4
- {B,A,C}: 3

**A의 조건부 패턴 베이스:**

| 경로 | 카운트 |
|------|--------|
| B→A | 5 |
| A | 1 |

**조건부 패턴:**
```
{B}:5
```

**A의 조건부 FP-Tree:**
```
항목 지지도:
B: 5 ✓

트리:
   null
    |
   B:5
```

**A로부터 빈발 패턴:**
- {A}: 6
- {B,A}: 5

**B의 조건부 패턴 베이스:**
```
B는 최상위 항목이므로 빈 경로
```

**B로부터 빈발 패턴:**
- {B}: 7

#### 최종 결과

**모든 빈발 항목집합:**

| k | 빈발 k-항목집합 | 지지도 |
|---|----------------|--------|
| 1 | {B} | 7 |
| 1 | {A} | 6 |
| 1 | {C} | 6 |
| 2 | {B,A} | 5 |
| 2 | {B,C} | 5 |
| 2 | {A,C} | 4 |
| 3 | {B,A,C} | 3 |

### 3.5 FP-Growth 의사코드

```python
Algorithm: FP-Growth
Input: 거래 데이터베이스 D, 최소 지지도 min_sup
Output: 빈발 항목집합

1. // Phase 1: FP-Tree 구축
2. L = {빈발 1-항목집합 찾기}
3. L을 지지도 내림차순 정렬
4. FP-Tree = 빈 트리 (루트 = null)
5. for each transaction T in D:
6.     T' = T에서 L에 있는 항목만 선택, 정렬
7.     insert_tree(T', FP-Tree)
8. 
9. // Phase 2: 패턴 마이닝
10. return FP_growth(FP-Tree, null)

Function: FP_growth(Tree, α)
1. if Tree가 단일 경로:
2.     return 경로의 모든 조합 + α
3. else:
4.     for each 항목 aᵢ in Header(Tree):
5.         β = aᵢ ∪ α
6.         β를 빈발 패턴으로 출력
7.         CPB = aᵢ의 조건부 패턴 베이스
8.         Cond_Tree = construct(CPB, min_sup)
9.         if Cond_Tree ≠ ∅:
10.            FP_growth(Cond_Tree, β)

Function: insert_tree(T', Tree)
1. current = Tree.root
2. for each item i in T':
3.     if current의 자식 중 i가 있으면:
4.         i.count++
5.     else:
6.         새 노드 i:1 생성
7.         current의 자식으로 추가
8.         Header의 노드 링크 갱신
9.     current = i 노드
```

### 3.6 FP-Growth 장단점

**장점:**
- 데이터베이스를 2번만 스캔 (Apriori는 k번)
- 후보 집합 생성 없음
- 메모리 효율적 (공통 경로 공유)
- 긴 패턴에서도 효율적

**단점:**
- 구현이 복잡함
- 작은 데이터셋에서는 오버헤드
- FP-Tree 구축 시간 필요

---

## 4. 알고리즘 비교

### 4.1 Apriori vs FP-Growth

| 특징 | Apriori | FP-Growth |
|------|---------|-----------|
| **후보 생성** | 많은 후보 생성 | 후보 생성 없음 |
| **스캔 횟수** | k번 (k는 최대 패턴 길이) | 2번 |
| **메모리** | 적음 | 많음 (트리 저장) |
| **속도** | 느림 | 빠름 |
| **구현 난이도** | 쉬움 | 어려움 |
| **적합한 경우** | 작은 데이터, 짧은 패턴 | 큰 데이터, 긴 패턴 |

### 4.2 성능 비교 표

**데이터 크기별 성능:**

| 거래 수 | Apriori 시간 | FP-Growth 시간 | 비율 |
|--------|-------------|---------------|------|
| 1,000 | 0.5초 | 0.3초 | 1.67x |
| 10,000 | 12초 | 3초 | 4x |
| 100,000 | 8분 | 45초 | 10.7x |
| 1,000,000 | 2시간 | 12분 | 10x |

**최소 지지도별 성능:**

| min_support | Apriori | FP-Growth | 우세 알고리즘 |
|-------------|---------|-----------|-------------|
| 10% | 느림 | 빠름 | FP-Growth |
| 20% | 보통 | 빠름 | FP-Growth |
| 30% | 보통 | 보통 | 비슷 |
| 40% | 빠름 | 보통 | 비슷 |
| 50% | 빠름 | 보통 | Apriori |

### 4.3 알고리즘 선택 가이드

**Apriori 선택:**
- 데이터가 작음 (<10,000 거래)
- 최소 지지도가 높음 (>30%)
- 구현의 단순성이 중요
- 교육/학습 목적

**FP-Growth 선택:**
- 데이터가 큼 (>100,000 거래)
- 최소 지지도가 낮음 (<10%)
- 긴 패턴 탐색
- 실시간 성능이 중요

---

## 5. 실전 문제

### 5.1 종합 문제 1: Apriori 계산

**문제:**

다음 거래 데이터에서 최소 지지도 40%, 최소 신뢰도 60%를 적용하여 Apriori 알고리즘으로 연관규칙을 구하시오.

| TID | 항목 |
|-----|------|
| 1 | I1, I2, I5 |
| 2 | I2, I4 |
| 3 | I2, I3 |
| 4 | I1, I2, I4 |
| 5 | I1, I3 |
| 6 | I2, I3 |
| 7 | I1, I3 |
| 8 | I1, I2, I3, I5 |
| 9 | I1, I2, I3 |

**풀이:**

**Step 1: 1-항목집합**

전체 거래 수: 9
최소 지지도 카운트: 9 × 40% = 3.6 → 4

| 항목 | 출현 TID | 카운트 | 지지도 | 결과 |
|------|----------|--------|--------|------|
| I1 | 1,4,5,7,8,9 | 6 | 66.7% | ✓ |
| I2 | 1,2,3,4,6,8,9 | 7 | 77.8% | ✓ |
| I3 | 3,5,6,7,8,9 | 6 | 66.7% | ✓ |
| I4 | 2,4 | 2 | 22.2% | ❌ |
| I5 | 1,8 | 2 | 22.2% | ❌ |

```
L₁ = {{I1}, {I2}, {I3}}
```

**Step 2: 2-항목집합**

| 항목집합 | 출현 TID | 카운트 | 지지도 | 결과 |
|----------|----------|--------|--------|------|
| {I1,I2} | 1,4,8,9 | 4 | 44.4% | ✓ |
| {I1,I3} | 5,7,8,9 | 4 | 44.4% | ✓ |
| {I2,I3} | 3,6,8,9 | 4 | 44.4% | ✓ |

```
L₂ = {{I1,I2}, {I1,I3}, {I2,I3}}
```

**Step 3: 3-항목집합**

| 항목집합 | 출현 TID | 카운트 | 지지도 | 결과 |
|----------|----------|--------|--------|------|
| {I1,I2,I3} | 8,9 | 2 | 22.2% | ❌ |

```
L₃ = ∅ (없음)
```

**빈발 항목집합 최종:**
- 1-항목: {I1}, {I2}, {I3}
- 2-항목: {I1,I2}, {I1,I3}, {I2,I3}

**Step 4: 연관규칙 생성 (최소 신뢰도 60%)**

**{I1,I2}로부터:**

| 규칙 | 지지도 | 신뢰도 | 향상도 | 채택 |
|------|--------|--------|--------|------|
| I1 → I2 | 44.4% | 4/6 = 66.7% | 0.857 | ✓ |
| I2 → I1 | 44.4% | 4/7 = 57.1% | - | ❌ |

**{I1,I3}로부터:**

| 규칙 | 지지도 | 신뢰도 | 향상도 | 채택 |
|------|--------|--------|--------|------|
| I1 → I3 | 44.4% | 4/6 = 66.7% | 1.0 | ✓ |
| I3 → I1 | 44.4% | 4/6 = 66.7% | 1.0 | ✓ |

**{I2,I3}로부터:**

| 규칙 | 지지도 | 신뢰도 | 향상도 | 채택 |
|------|--------|--------|--------|------|
| I2 → I3 | 44.4% | 4/7 = 57.1% | - | ❌ |
| I3 → I2 | 44.4% | 4/6 = 66.7% | 0.857 | ✓ |

**최종 연관규칙:**
1. I1 → I2: 신뢰도 66.7%, 향상도 0.857
2. I1 → I3: 신뢰도 66.7%, 향상도 1.0
3. I3 → I1: 신뢰도 66.7%, 향상도 1.0
4. I3 → I2: 신뢰도 66.7%, 향상도 0.857

### 5.2 종합 문제 2: 부분집합과 Apriori 원리

**문제:**

항목집합 {A, B, C, D}에서:
1. 모든 부분집합을 나열하시오.
2. {B, C}가 비빈발이면, 어떤 항목집합들이 빈발하지 않음을 보장할 수 있는가?

**풀이:**

**1. 모든 부분집합 (2^4 - 1 = 15개)**

| k | 부분집합 |
|---|----------|
| 1 | {A}, {B}, {C}, {D} |
| 2 | {A,B}, {A,C}, {A,D}, {B,C}, {B,D}, {C,D} |
| 3 | {A,B,C}, {A,B,D}, {A,C,D}, {B,C,D} |
| 4 | {A,B,C,D} |

**2. {B,C}가 비빈발일 때**

Apriori 원리: "비빈발 항목집합을 포함하는 모든 상위집합도 비빈발"

**{B,C}를 포함하는 상위집합:**
- {A,B,C}
- {B,C,D}
- {A,B,C,D}

**보장되는 비빈발 항목집합:**
```
{B,C}, {A,B,C}, {B,C,D}, {A,B,C,D}
```

**가지치기 효과:**
- 전체 15개 → 4개는 확실히 비빈발
- 나머지 11개만 검사하면 됨

### 5.3 종합 문제 3: FP-Tree 구축

**문제:**

다음 거래 데이터로 FP-Tree를 구축하시오 (최소 지지도 = 2).

| TID | 항목 |
|-----|------|
| T1 | f, a, c, d, g, i, m, p |
| T2 | a, b, c, f, l, m, o |
| T3 | b, f, h, j, o |
| T4 | b, c, k, s, p |
| T5 | a, f, c, e, l, p, m, n |

**풀이:**

**Step 1: 빈발 1-항목 (지지도 ≥ 2)**

| 항목 | 출현 | 카운트 |
|------|------|--------|
| a | T1,T2,T5 | 3 ✓ |
| b | T2,T3,T4 | 3 ✓ |
| c | T1,T2,T4,T5 | 4 ✓ |
| f | T1,T2,T3,T5 | 4 ✓ |
| m | T1,T2,T5 | 3 ✓ |
| p | T1,T4,T5 | 3 ✓ |
| 기타 | - | <2 ❌ |

**정렬 (빈도순):** f(4) > c(4) > a(3) > b(3) > m(3) > p(3)

**Step 2: 거래 정렬 및 필터링**

| TID | 정렬된 항목 |
|-----|------------|
| T1 | f, c, a, m, p |
| T2 | f, c, a, b, m |
| T3 | f, b |
| T4 | c, b, p |
| T5 | f, c, a, m, p |

**Step 3: FP-Tree 구축**

```
최종 FP-Tree:

          null
           |
          f:4
         / \
       c:3  b:1
       / \
     a:3  b:1→p:1
     |
    m:2→p:1
    |
   p:2
```

**헤더 테이블:**

| 항목 | 카운트 | 노드 링크 |
|------|--------|----------|
| f | 4 | → f:4 |
| c | 4 | → c:3 → c:1 |
| a | 3 | → a:3 |
| b | 3 | → b:1 → b:1 |
| m | 3 | → m:2 → m:1 |
| p | 3 | → p:2 → p:1 → p:1 |

---

## 6. Python 구현

### 6.1 Apriori 알고리즘

```python
from itertools import combinations
from collections import defaultdict

def apriori(transactions, min_support):
    """
    Apriori 알고리즘 구현
    
    Parameters:
    - transactions: 거래 리스트 (각 거래는 집합)
    - min_support: 최소 지지도 (0~1 사이)
    
    Returns:
    - frequent_itemsets: 빈발 항목집합 딕셔너리 {항목집합: 지지도}
    """
    n_transactions = len(transactions)
    min_count = int(min_support * n_transactions)
    
    # 1-항목집합 생성
    item_counts = defaultdict(int)
    for transaction in transactions:
        for item in transaction:
            item_counts[frozenset([item])] += 1
    
    # 빈발 1-항목집합
    frequent_itemsets = {
        itemset: count / n_transactions 
        for itemset, count in item_counts.items() 
        if count >= min_count
    }
    
    current_itemsets = set(frequent_itemsets.keys())
    k = 2
    
    # k-항목집합 생성
    while current_itemsets:
        # 후보 생성
        candidates = set()
        itemsets_list = list(current_itemsets)
        
        for i in range(len(itemsets_list)):
            for j in range(i + 1, len(itemsets_list)):
                union = itemsets_list[i] | itemsets_list[j]
                if len(union) == k:
                    # Apriori 원리: 모든 부분집합이 빈발해야 함
                    subsets = [frozenset(s) for s in combinations(union, k-1)]
                    if all(s in frequent_itemsets for s in subsets):
                        candidates.add(union)
        
        # 지지도 계산
        candidate_counts = defaultdict(int)
        for transaction in transactions:
            for candidate in candidates:
                if candidate.issubset(transaction):
                    candidate_counts[candidate] += 1
        
        # 빈발 항목집합 선택
        new_frequent = {
            itemset: count / n_transactions 
            for itemset, count in candidate_counts.items() 
            if count >= min_count
        }
        
        if not new_frequent:
            break
        
        frequent_itemsets.update(new_frequent)
        current_itemsets = set(new_frequent.keys())
        k += 1
    
    return frequent_itemsets

def generate_rules(frequent_itemsets, min_confidence):
    """
    연관규칙 생성
    
    Parameters:
    - frequent_itemsets: 빈발 항목집합 딕셔너리
    - min_confidence: 최소 신뢰도 (0~1 사이)
    
    Returns:
    - rules: [(선행항목, 후행항목, 신뢰도, 향상도), ...]
    """
    rules = []
    
    for itemset in frequent_itemsets:
        if len(itemset) < 2:
            continue
        
        itemset_support = frequent_itemsets[itemset]
        
        # 모든 비어있지 않은 부분집합 생성
        for i in range(1, len(itemset)):
            for antecedent in combinations(itemset, i):
                antecedent = frozenset(antecedent)
                consequent = itemset - antecedent
                
                if antecedent in frequent_itemsets:
                    antecedent_support = frequent_itemsets[antecedent]
                    confidence = itemset_support / antecedent_support
                    
                    if confidence >= min_confidence:
                        consequent_support = frequent_itemsets[consequent]
                        lift = confidence / consequent_support
                        
                        rules.append((
                            set(antecedent),
                            set(consequent),
                            confidence,
                            lift
                        ))
    
    return rules

# 사용 예제
if __name__ == "__main__":
    # 거래 데이터
    transactions = [
        {'A', 'B', 'C'},
        {'A', 'C'},
        {'A', 'B'},
        {'B', 'C', 'D'},
        {'A', 'B', 'C'},
        {'B', 'C'},
        {'A', 'B'},
        {'A', 'B', 'C', 'D'}
    ]
    
    # Apriori 실행
    min_support = 0.375
    frequent_itemsets = apriori(transactions, min_support)
    
    print("빈발 항목집합:")
    for itemset, support in sorted(frequent_itemsets.items(), key=lambda x: len(x[0])):
        print(f"{set(itemset)}: {support:.3f}")
    
    # 연관규칙 생성
    min_confidence = 0.6
    rules = generate_rules(frequent_itemsets, min_confidence)
    
    print("\n연관규칙:")
    for ant, cons, conf, lift in rules:
        print(f"{ant} → {cons}: conf={conf:.3f}, lift={lift:.3f}")
```

### 6.2 FP-Growth 알고리즘

```python
from collections import defaultdict, Counter

class FPNode:
    """FP-Tree 노드"""
    def __init__(self, item, count, parent):
        self.item = item
        self.count = count
        self.parent = parent
        self.children = {}
        self.next = None  # 같은 항목의 다음 노드
    
    def increment(self, count):
        self.count += count

class FPTree:
    """FP-Tree 구조"""
    def __init__(self, transactions, min_support):
        self.min_support = min_support
        self.headers = {}  # 헤더 테이블
        self.root = FPNode(None, 0, None)
        
        # 1단계: 빈발 항목 찾기 및 정렬
        item_counts = Counter()
        for transaction in transactions:
            item_counts.update(transaction)
        
        # 빈발 항목만 선택하고 빈도순 정렬
        frequent_items = {
            item: count 
            for item, count in item_counts.items() 
            if count >= min_support
        }
        
        if not frequent_items:
            return
        
        # 빈도순으로 정렬 (내림차순)
        self.frequent_items = dict(
            sorted(frequent_items.items(), key=lambda x: x[1], reverse=True)
        )
        
        # 2단계: FP-Tree 구축
        for transaction in transactions:
            # 빈발항목만 필터링하고 정렬
            sorted_items = [
                item for item in self.frequent_items.keys() 
                if item in transaction
            ]
            if sorted_items:
                self.insert_transaction(sorted_items, self.root, 1)
    
    def insert_transaction(self, items, node, count):
        """트리에 거래 삽입"""
        if not items:
            return
        
        first_item = items[0]
        
        if first_item in node.children:
            # 기존 노드 카운트 증가
            child = node.children[first_item]
            child.increment(count)
        else:
            # 새 노드 생성
            child = FPNode(first_item, count, node)
            node.children[first_item] = child
            
            # 헤더 테이블 업데이트
            if first_item in self.headers:
                # 링크 연결
                current = self.headers[first_item]
                while current.next:
                    current = current.next
                current.next = child
            else:
                self.headers[first_item] = child
        
        # 재귀적으로 나머지 항목 삽입
        if len(items) > 1:
            self.insert_transaction(items[1:], child, count)
    
    def get_paths(self, item):
        """특정 항목의 모든 경로 반환"""
        paths = []
        node = self.headers.get(item)
        
        while node:
            path = []
            parent = node.parent
            
            # 루트까지 역추적
            while parent.parent:
                path.append(parent.item)
                parent = parent.parent
            
            if path:
                paths.append((path[::-1], node.count))
            
            node = node.next
        
        return paths

def fp_growth(transactions, min_support):
    """
    FP-Growth 알고리즘 구현
    
    Parameters:
    - transactions: 거래 리스트
    - min_support: 최소 지지도 카운트
    
    Returns:
    - patterns: 빈발 패턴 딕셔너리 {항목집합: 지지도}
    """
    tree = FPTree(transactions, min_support)
    
    if not tree.frequent_items:
        return {}
    
    patterns = {}
    
    # 각 빈발 항목에 대해
    for item in reversed(list(tree.frequent_items.keys())):
        # 항목 자체를 패턴에 추가
        support = tree.frequent_items[item]
        patterns[frozenset([item])] = support
        
        # 조건부 패턴 베이스 생성
        conditional_patterns = tree.get_paths(item)
        
        if conditional_patterns:
            # 조건부 FP-Tree 생성
            conditional_transactions = []
            for path, count in conditional_patterns:
                for _ in range(count):
                    conditional_transactions.append(path)
            
            # 재귀적으로 FP-Growth 수행
            conditional_patterns_dict = fp_growth(
                conditional_transactions, 
                min_support
            )
            
            # 현재 항목과 조합
            for pattern, count in conditional_patterns_dict.items():
                new_pattern = pattern | frozenset([item])
                patterns[new_pattern] = count
    
    return patterns

# 사용 예제
if __name__ == "__main__":
    # 거래 데이터
    transactions = [
        ['A', 'B', 'C'],
        ['A', 'C'],
        ['A', 'B'],
        ['B', 'C', 'D'],
        ['A', 'B', 'C'],
        ['B', 'C'],
        ['A', 'B'],
        ['A', 'B', 'C', 'D']
    ]
    
    # FP-Growth 실행
    min_support = 3
    patterns = fp_growth(transactions, min_support)
    
    print("빈발 패턴:")
    for pattern, support in sorted(patterns.items(), key=lambda x: (len(x[0]), x[1]), reverse=True):
        print(f"{set(pattern)}: {support}")
```

### 6.3 mlxtend 라이브러리 사용

```python
import pandas as pd
from mlxtend.frequent_patterns import apriori, fpgrowth, association_rules
from mlxtend.preprocessing import TransactionEncoder

# 거래 데이터
transactions = [
    ['우유', '빵', '버터'],
    ['우유', '빵'],
    ['우유', '계란'],
    ['빵', '버터'],
    ['우유', '빵', '버터', '계란'],
    ['빵', '계란'],
    ['우유', '버터'],
    ['우유', '빵', '버터'],
    ['빵', '버터', '계란'],
    ['우유', '계란']
]

# One-hot encoding
te = TransactionEncoder()
te_ary = te.fit(transactions).transform(transactions)
df = pd.DataFrame(te_ary, columns=te.columns_)

print("거래 데이터 (One-hot):")
print(df)
print()

# Apriori 알고리즘
print("=== Apriori ===")
frequent_itemsets_apriori = apriori(df, min_support=0.3, use_colnames=True)
print(frequent_itemsets_apriori)
print()

# FP-Growth 알고리즘
print("=== FP-Growth ===")
frequent_itemsets_fp = fpgrowth(df, min_support=0.3, use_colnames=True)
print(frequent_itemsets_fp)
print()

# 연관규칙 생성
rules = association_rules(
    frequent_itemsets_fp, 
    metric="confidence", 
    min_threshold=0.5
)

print("=== 연관규칙 ===")
print(rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']])
```

---

## 7. 빅데이터분석기사 시험 대비

### 7.1 핵심 개념 정리

| 개념 | 설명 | 시험 출제 빈도 |
|------|------|---------------|
| **Apriori 원리** | 빈발집합의 부분집합도 빈발 | ★★★★★ |
| **지지도** | Support(X) = P(X) | ★★★★★ |
| **신뢰도** | Confidence(X→Y) = P(Y\|X) | ★★★★★ |
| **향상도** | Lift = Conf / P(Y) | ★★★★ |
| **FP-Tree** | 압축된 데이터 구조 | ★★★ |
| **조건부 패턴** | 특정 항목의 경로들 | ★★ |

### 7.2 시험 유형별 대비

#### 유형 1: 빈발 항목집합 찾기

**출제 패턴:**
- 거래 데이터 제공
- 최소 지지도 주어짐
- Apriori로 빈발집합 구하기

**풀이 팁:**
1. 표를 만들어 체계적으로 계산
2. 1-항목부터 순서대로
3. 비빈발은 즉시 제거

#### 유형 2: 연관규칙 생성

**출제 패턴:**
- 빈발집합 주어짐
- 최소 신뢰도 주어짐
- 연관규칙과 향상도 계산

**풀이 팁:**
1. 2개 이상 항목집합만 사용
2. 모든 가능한 규칙 나열
3. 신뢰도 = 지지도(X∪Y) / 지지도(X)
4. 향상도 = 신뢰도 / 지지도(Y)

#### 유형 3: Apriori 원리 적용

**출제 패턴:**
- 특정 항목집합이 비빈발
- 어떤 집합들이 비빈발인지 판단

**풀이 팁:**
- 비빈발 항목집합을 포함하는 모든 상위집합 나열

### 7.3 자주 나오는 함정

| 함정 | 설명 | 대응 방법 |
|------|------|----------|
| **지지도 vs 신뢰도** | 개념 혼동 | 공식 정확히 암기 |
| **향상도 해석** | >1, =1, <1 의미 | 독립성 기준 이해 |
| **부분집합 개수** | 2^k 계산 실수 | 공집합 제외 확인 |
| **최소 지지도** | % vs 절대값 | 문제에서 확인 |

### 7.4 실전 체크리스트

**Apriori 계산 시:**
- [ ] 전체 거래 수 확인
- [ ] 최소 지지도를 카운트로 변환
- [ ] 각 단계마다 표 작성
- [ ] 비빈발 항목 즉시 제거
- [ ] 결과를 명확히 표시

**연관규칙 생성 시:**
- [ ] k≥2인 빈발집합만 사용
- [ ] 모든 가능한 규칙 고려
- [ ] 신뢰도 공식 정확히 적용
- [ ] 향상도 계산 및 해석
- [ ] 최소 신뢰도 만족 확인

### 7.5 공식 암기 카드

```
┌─────────────────────────────────┐
│ 지지도 (Support)                 │
│ Support(X) = |X| / |D|          │
│                                 │
│ 신뢰도 (Confidence)              │
│ Conf(X→Y) = Sup(X∪Y) / Sup(X) │
│                                 │
│ 향상도 (Lift)                    │
│ Lift(X→Y) = Conf / Sup(Y)      │
│                                 │
│ Apriori 원리                     │
│ 빈발의 부분집합 → 빈발            │
│ 비빈발의 상위집합 → 비빈발        │
└─────────────────────────────────┘
```

---

## 8. 참고자료

### 8.1 추가 학습 주제

- **순차 패턴 마이닝 (Sequential Pattern Mining)**
  - GSP, PrefixSpan 알고리즘
  - 시간 순서가 있는 데이터 분석

- **최대/닫힌 항목집합 (Maximal/Closed Itemsets)**
  - 빈발 항목집합의 간결한 표현
  - 메모리 효율성 증가

- **다단계 연관규칙 (Multi-level Association Rules)**
  - 상품 계층구조 활용
  - 일반화/특수화 규칙

### 8.2 실무 응용 분야

| 분야 | 응용 |
|------|------|
| **소매/유통** | 상품 배치, 프로모션 기획 |
| **웹 분석** | 페이지 연관성, 추천 시스템 |
| **의료** | 증상-질병 연관성 분석 |
| **통신** | 고객 이탈 패턴 분석 |
| **금융** | 사기 거래 탐지 패턴 |

### 8.3 관련 알고리즘

- **Eclat**: 수직 데이터 형식 사용
- **H-Mine**: 메모리 효율적 마이닝
- **CHARM**: 닫힌 항목집합 탐색
- **FP-Growth***: 다양한 FP-Growth 변형

---

## 요약

### 핵심 포인트

1. **Apriori**
   - 후보 생성 → 지지도 계산 → 가지치기
   - 간단하지만 대규모 데이터에서 느림

2. **FP-Growth**
   - FP-Tree 구축 → 조건부 패턴 마이닝
   - 빠르지만 구현 복잡

3. **부분집합**
   - Apriori 원리의 핵심
   - 가지치기로 효율성 증대

4. **연관규칙**
   - 지지도, 신뢰도, 향상도
   - 향상도 > 1이 의미 있는 규칙

### 시험 전 최종 점검

- [ ] Apriori 알고리즘 흐름 숙지
- [ ] FP-Tree 구축 과정 이해
- [ ] 지지도/신뢰도/향상도 공식 암기
- [ ] Apriori 원리 정확히 이해
- [ ] 부분집합 개념 명확히
- [ ] 손으로 계산 연습 충분히

---

**작성일:** 2026년 1월  
**용도:** 빅데이터분석기사 연관규칙 마이닝 완벽 대비
